---
title: Data Mutation
---

import { CodeBlock, dracula } from 'react-code-blocks';

## Data Mutation

Data mutation in Remix is build on top of two fundamental web APIs: `<form>` and
HTTP. Let's go over how it works.

<br />

### Forms

Really, we want to use forms? I love my hook based library for keeping form
state up to date and then submitting it. I was skeptical too until I saw it in
action.

The Remix `<Form />` component lets us declaratively perform data mutations
without the full page refresh issues and `preventDefault` work around we
commonly see. Let's look at a basic example:

<CodeBlock
  text={`
export default function SomeRoute() {
  return (
    <Form method="post">
      <input type="text" name="firstName" />
      <input type="text" name="lastName" />
      <button type="submit">Submit</button>
    </Form>
  );
}

`} language="TypeScript" showLineNumbers={false} theme={dracula} />

<br />

We have a `<form>` element that will `post` it's data when submitted. Yes, the
browser keeps track of the data for you! The `formData` will have `firstName`
and `lastName` properties. But where does it get submitted? That's where Remix
actions come inasdf.

<br />

### Actions

Actions are like loaders, but instead of calling GET on the route for data we're
POST-ing to a route action.

<CodeBlock
  text={`
export async function action({ request }) {
  const formData = await request.formData();
  const firstName = formData.get('firstName');
  const lastName = formData.get('lastName');
  const { id } = await createMember(firstName, lastName);
  return redirect('/members/{id}'); // incorrect syntax but my CodeBlock plugin doesn't have a fix :)
}

`} language="TypeScript" showLineNumbers={false} theme={dracula} />

<br />

The above form will by default post to the same action as the route the form was
defined. The action gets data from the `formData` on the `request`. After we
perform the operations the action is responsible for we redirect to a new page.
Remix automatically revalidates data for the application after the mutation
occurs.

There's a lot of levers Remix gives us to customize these actions. We don't
always want to navigate to a new page, or we have multiple actions that need to
be on the same route. Maybe we aren't posting data but still need to indicate a
mutation should occur. Remix covers many cases around mutations.

There's too much to go over in this workshop, but I'm excited to demo additional
use cases in the next section.
