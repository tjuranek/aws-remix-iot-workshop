---
title: Routing
---

import { CodeBlock, dracula } from 'react-code-blocks';

## Routing

"Routing is possibly the most important concept to understand in Remix.
Everything starts with your routes: the compiler, the initial request, and
almost every user interaction afterward." - Remix Docs

<br />

### Terms

A route is a JavaScript module with some expected exports that corresponds to a
specific path - or segment of the URL. For example, /posts is a path that would
correlate to the Posts route.

Nested routing refers to the idea of mapping segments of the URL to a hierarchy
of route components. The /authors/thomas path would correspond to both the
Authors route and an Author route.

<br />

### Defining a Route

In Remix, we define a route module by creating a new file under the `app/routes`
folder. The only requirement is the route must export a default function that
returns the JSX you'd like to render on that page. As you can imagine, that
might look really simple:

<CodeBlock
  text={`
  export default function SomeFunctionName() {
    return <p>This text shows up on the page!</p>
  }

`} showLineNumbers={false} theme={dracula} language="TypeScript" />

<br />

You can treat this function like pretty much any other React component. Import
other components, use hooks, just always return some markup to render on the
page. Remix will server render this and return it to the browser any time this
page is requested.

<br />

### Nested Routing

By default, all routes in Remix get defined in the app/routes folder.
app/routes/index.tsx would be yourdomain.com/.

We're able to map new routes to different paths through the file system. For
example, we could a /login route like this:

<CodeBlock
  text={`
    app
    -- routes
    -- -- index.jsx (/)
    -- -- login.jsx (/login) 
  `}
  showLineNumbers={false}
  theme={dracula}
/>

<br />

But what if we wanted to go a couple of layers deep in the route? Using the
above example, how could we create an authors route that might display a list of
authors, but also an individual author page?

<CodeBlock
  text={`
    app
    -- routes
    -- -- authors
    -- -- -- $author.jsx (/authors/$author)
    -- -- index.jsx (/)
    -- -- authors.jsx (/authors) 
  `}
  showLineNumbers={false}
  theme={dracula}
/>

We created an `authors.jsx` file under the `/routes` folder. That will be the
`/authors` path. To go past `/authors` we need to create an
`/authors/$author.jsx` file that will correspond to the `/authors/author` path.
Having files nested under each other and building out the path of our routes is
known as nested routing.

<br />

### Parameters

Did you notice the `$author` before? That's how Remix takes in arguments for url
parameters. Any term can be used and accessed in the route. We can even add
multiple parameters to different parts of the path! We could even define a
longer path using nested routing like this:
`/authors/$author/books/$book/reviews`. The author and book arguments will be
available in that route on the `Request` object, which we'll cover in the next
section under `Loaders`.

<br />

### Layouts

It's very common to share layouts between different routes in web applications.
Take this workshop site for example! The main page has a unique layout, but
everything under `/modules` uses a layout with a menu and sidebar.

You might think I created a layout component and then used that on every route,
but you'd be wrong. Remix makes that even easier with Nested Layouts. The best
way to explain this is to show it.

This is the route hierarchy of this website:

<CodeBlock
  text={`
    app
    -- modules
    -- -- introduction (/modules/introduction)
    -- -- -- define-a-tech-stack.mdx (/modules/introduction/define-a-tech-stack)
    -- -- -- prerequisites.mdx (/modules/introduction/prerequisites)
    -- -- -- ...
    -- -- ...
    -- -- index.mdx (/modules)
    -- index.tsx (/)
    -- modules.tsx (/modules)
  `}
  showLineNumbers={false}
  theme={dracula}
/>

Ignore the `.mdx` extension. It's Remix's easy way of turning markdown files
into routes. The focus here is that I have a modules base route, then a modules
folder with different routes under that.

The `modules.tsx` file defines the layout I want every route under `/modules` to
use. I can control where I want my subroutes to render in the layout using a
Remix component called `<Outlet />`. It means the rest of the route will render
in that specific section. Here's a basic example:

<CodeBlock
  text={`
    return (
      <div className="layout">
        <div className="menu" />
        <div className="sidebar" />
        <div className="content">
          <Outlet />
        </div>
      </div>
    )

`} language='TypeScript' showLineNumbers={false} theme={dracula} />

Anything that is a nested route below this `/modules` path will get rendered in
the `<Outlet />`. Right now you're seeing my markdown pages get rendered in the
`<Outlet />` of my `/modules` nested layout. Pretty cool, right?

### Exercise

Time for our first exercise! Let's create our own routes!

Under the `exercies/routing` folder in the workshop repository you'll find a
boilerplate Remix application. Under `/app/routing` there is just one route -
the index route.

Let's do a few things to try out what we just learned:

- Create a new `/ping` route that renders text saying "pong" on the screen.
- Make a layout route for all pages under the `/pet` route that renders a
  sidebar on the page. (The CSS classes are under /styles/global.css and are
  already available on the page using `className`!)
- BONUS: Setup a route under `/pet` that accepts a pet name as a parameter and
  renders it in the content section of the layout you made! (Destructuring your
  param from the `useParms()` hook would be useful here!)

<br />

Next we'll go over how to load data in our routes!
